<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Crypto News</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .article-content p {
            margin-bottom: 1rem;
        }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Automated Crypto News</h1>
            <p class="text-lg text-gray-600 mt-2">Fresh articles generated by AI every 3 minutes.</p>
        </header>

        <main id="main-content">
            <!-- Status and Countdown Timer -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <div class="flex justify-between items-center">
                    <div>
                        <h2 class="text-xl font-semibold">Status</h2>
                        <p id="status-message" class="text-gray-600">Initializing...</p>
                    </div>
                    <div class="text-right">
                        <h2 class="text-xl font-semibold">Next Article In</h2>
                        <p id="countdown-timer" class="text-2xl font-bold text-indigo-600">--:--</p>
                    </div>
                </div>
                <div id="loading-indicator" class="hidden mt-4">
                    <div class="flex items-center justify-center">
                        <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 mr-3"></div>
                        <p id="loading-message">Generating new article...</p>
                    </div>
                </div>
            </div>

            <!-- Articles Section -->
            <div id="articles-container" class="space-y-8">
                <!-- Placeholder for initial loading -->
                 <div class="bg-white rounded-lg shadow-md p-6 animate-pulse">
                    <div class="h-8 bg-gray-200 rounded w-3/4 mb-4"></div>
                    <div class="space-y-3">
                        <div class="h-4 bg-gray-200 rounded"></div>
                        <div class="h-4 bg-gray-200 rounded"></div>
                        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                    </div>
                     <div class="text-sm text-gray-400 mt-4 h-4 bg-gray-200 rounded w-1/4"></div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, orderBy, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'crypto-news-private-path-fix';
        
        const POST_INTERVAL_MS = 3 * 60 * 1000; // 3 minutes

        // --- DOM ELEMENTS ---
        const statusMessageEl = document.getElementById('status-message');
        const countdownTimerEl = document.getElementById('countdown-timer');
        const articlesContainerEl = document.getElementById('articles-container');
        const loadingIndicatorEl = document.getElementById('loading-indicator');
        const loadingMessageEl = document.getElementById('loading-message');

        // --- STATE & TIMER VARIABLES ---
        let db, auth, userId;
        let countdownInterval;
        let articles = [];
        let dbPath; // Will be set after authentication

        // --- FIREBASE INITIALIZATION ---
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            statusMessageEl.textContent = "Error: Could not connect to the database.";
        }
        
        // --- AUTHENTICATION ---
        onAuthStateChanged(auth, async (user) => {
            if (user && !userId) {
                userId = user.uid;
                console.log("User authenticated with UID:", userId);
                // ** CRITICAL FIX: Use the private user data path **
                dbPath = `artifacts/${appId}/users/${userId}/articles`;
                initialize();
            } else if (!user) {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Anonymous sign-in failed:", error);
                    statusMessageEl.textContent = "Authentication failed.";
                }
            }
        });

        // --- CORE LOGIC ---
        function initialize() {
            statusMessageEl.textContent = "Connecting to article stream...";
            listenForArticles();
            startArticleGenerationCycle();
        }

        function renderArticles() {
            if (articles.length === 0) {
                articlesContainerEl.innerHTML = '<div class="bg-white rounded-lg shadow-md p-6 text-center text-gray-500">No articles yet. The first one will be generated shortly...</div>';
                return;
            }
            
            articlesContainerEl.innerHTML = '';
            articles.forEach(article => {
                const articleEl = document.createElement('div');
                articleEl.className = 'bg-white rounded-lg shadow-md p-6';
                
                const formattedDate = article.createdAt?.seconds ? new Date(article.createdAt.seconds * 1000).toLocaleString() : 'Just now';
                const formattedContent = (article.content || "").split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');

                articleEl.innerHTML = `
                    <h3 class="text-2xl font-bold mb-3">${article.title || "Untitled"}</h3>
                    <div class="text-gray-700 article-content">${formattedContent}</div>
                    <p class="text-sm text-gray-500 mt-4">Posted: ${formattedDate}</p>
                `;
                articlesContainerEl.appendChild(articleEl);
            });
        }

        function listenForArticles() {
            if (!dbPath) return;
            console.log("Listening for articles at private path:", dbPath);
            const articlesRef = collection(db, dbPath);
            const q = query(articlesRef, orderBy("createdAt", "desc"), limit(20));

            onSnapshot(q, (snapshot) => {
                console.log(`Firestore snapshot received with ${snapshot.docs.length} documents.`);
                articles = snapshot.docs.map(doc => doc.data());
                renderArticles();
                statusMessageEl.textContent = "Idle. Waiting for next schedule.";
            }, (error) => {
                console.error("Firestore listener error:", error);
                statusMessageEl.textContent = `Read Error: ${error.code}`;
            });
        }

        function startArticleGenerationCycle() {
            runJob(); 
            setInterval(runJob, POST_INTERVAL_MS);
        }
        
        async function runJob() {
            if (!dbPath) {
                console.error("Cannot run job, database path not set.");
                return;
            }
            console.log("--- Starting New Article Job ---");
            loadingIndicatorEl.classList.remove('hidden');
            startCountdown(POST_INTERVAL_MS);

            try {
                loadingMessageEl.textContent = "Fetching latest crypto news...";
                const newsItem = await fetchCryptoNews();
                if (!newsItem) throw new Error("Could not fetch crypto news.");

                loadingMessageEl.textContent = `Generating article for: "${newsItem.title}"`;
                const articleContent = await generateArticle(newsItem);
                if (!articleContent) throw new Error("AI article generation failed.");

                loadingMessageEl.textContent = "Saving new article...";
                await postArticleToFirestore(newsItem.title, articleContent);

                console.log("--- Job Completed Successfully ---");
                statusMessageEl.textContent = "Article created! Waiting for next schedule.";

            } catch (error) {
                console.error("Article generation cycle failed:", error.message);
                statusMessageEl.textContent = `Error: ${error.message}`;
            } finally {
                loadingIndicatorEl.classList.add('hidden');
            }
        }

        async function fetchCryptoNews() {
            const url = 'https://min-api.cryptocompare.com/data/v2/news/?lang=EN';
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`News API request failed with status ${response.status}`);
                const data = await response.json();
                if (data.Type === 100 && data.Data?.length > 0) {
                    const latestNews = data.Data[0];
                    return { title: latestNews.title, body: latestNews.body };
                }
                return null;
            } catch (error) {
                console.error("FETCH NEWS FAILED:", error);
                return null;
            }
        }

        async function generateArticle(newsItem) {
            const prompt = `You are a crypto news analyst. Write a short, insightful news article based on the following headline and summary. The article should be objective, well-structured, and about 3-4 paragraphs long. Do not use markdown formatting.

Headline: "${newsItem.title}"

Summary: "${newsItem.body}"
`;
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Gemini API request failed with status ${response.status}`);
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) return text;
                throw new Error("Invalid response structure from Gemini API.");
            } catch (error) {
                console.error("GENERATE ARTICLE FAILED:", error);
                return null;
            }
        }

        async function postArticleToFirestore(title, content) {
            if (!dbPath) throw new Error("Database path not initialized.");
            console.log("Attempting to post article to private path:", dbPath);
            const articlesRef = collection(db, dbPath);
            
            const articleData = {
                title: title || "Untitled Article",
                content: content || "Content could not be generated.",
                createdAt: serverTimestamp()
            };

            try {
                const docRef = await addDoc(articlesRef, articleData);
                console.log("SUCCESS: Article posted to Firestore with ID:", docRef.id);
            } catch (error) {
                console.error("POST TO FIRESTORE FAILED:", error);
                throw new Error(`Write Error: ${error.code}`);
            }
        }
        
        function startCountdown(duration) {
            let timeLeft = duration;
            if (countdownInterval) clearInterval(countdownInterval);

            countdownInterval = setInterval(() => {
                timeLeft -= 1000;
                const minutes = Math.floor((timeLeft / 1000) / 60);
                const seconds = Math.floor((timeLeft / 1000) % 60);
                
                if (timeLeft < 0) {
                    clearInterval(countdownInterval);
                    countdownTimerEl.textContent = "00:00";
                } else {
                    countdownTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
    </script>
</body>
</html>

